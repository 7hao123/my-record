# 低代码可视化画布项目亮点总结（面试向）

## 一、项目一句话定位
这是一个基于配置驱动（Schema）的低代码可视化画布系统，支持拖拽物料快速搭建报表、看板和表单页面，并将编辑结果序列化为可持久化、可回放的页面配置。

## 二、项目背景 & 业务价值（Why it matters）
传统报表开发的痛点是高频小改动依赖研发反复改代码：字段调整、筛选变更、图表替换都要经历开发、联调、发布，导致响应慢、成本高。弱技术角色很难独立完成页面搭建，业务表达与交付之间存在明显断层。
该项目通过‘可视化画布 + 配置驱动’将页面生产从代码实现转为配置编排，研发侧沉淀底层能力，业务侧提升搭建效率和复用能力，具备模板化扩展与平台化演进价值。

## 三、核心功能模块拆解（What & How）
### 3.1 可视化画布系统
- 画布交互由 Canvas + MoveableBox 实现，支持拖拽、缩放、框选、多选、吸附与对齐。
- 编辑状态集中在 editorSlice，降低复杂交互状态爆炸风险。
- 通过 Layer 管理显隐与层级，提升编辑行为可治理性。

### 3.2 物料（组件）体系设计
- 物料在 boxTypes 中统一定义类型、默认配置、校验规则和图标，形成协议化描述。
- 通过 type -> componentMap 的渲染分发机制实现物料解耦。
- 右侧属性面板按 selectedBox.type 动态切换，支持配置能力按类型扩展。

### 3.3 Schema / 配置驱动能力
- 页面以 views.configData(JSON) 存储，形成统一配置中间态。
- useReport 负责配置回放到编辑器，HeaderRight 负责配置序列化保存。
- preview 路由复用同一配置链路，保证编辑态与预览态语义一致。

### 3.4 数据 & 图表体系
- useBoxData 统一数据请求、占位数据、错误归一与排序后处理。
- useRequestParams 统一封装筛选、下钻、日期、分页、排序参数。
- useBoxDataRequestable 在请求前做类型化门禁，减少无效请求。

## 四、技术难点 & 解决方案
1) 状态爆炸：通过 editorSlice 原子 action 统一写路径，避免交互逻辑分散。
2) 撤销重做：store 中 editor 使用 redux-undo 包装，保证可试错与可回退。
3) 配置一致性：以 configData 作为单一真相，贯通编辑、保存、预览。
4) 数据复杂度：三段式管线（参数构建-请求门禁-统一拉取）降低重复实现。
5) 容器语义：通过 tabsId/paneId 与相对位移处理容器内拖拽编排。

## 五、工程化与架构设计
- 分层：编辑层（交互状态）/ 物料层（组件协议）/ 配置层（Schema序列化）/ 数据层（请求管线）。
- 治理：Redux + React Query + axios 拦截器 + 未保存离开提示，保证可维护与可协作。
- 复杂度：核心在交互引擎、配置协议、数据链路协同，而非单组件实现。

## 六、可扩展性 & 演进方向
- 新物料可沿 boxTypes + componentMap + 配置Tabs 接入，具备横向扩展能力。
- 图表库可在渲染层替换，配置层保持稳定。
- 平台化建议：补齐权限、模板市场、版本管理、多人协作、审批发布能力。

## 七、面向大厂面试的项目亮点总结
这个项目的关键不在‘做了拖拽功能’，而在把页面生产抽象成可治理的配置执行体系。通过协议先行、分层解耦和状态治理，系统同时兼顾了短期交付效率与长期平台化演进能力。

## 八、简历项目描述（可直接使用）
- 设计并实现基于 Schema 的低代码可视化画布，支持报表/看板/表单配置化搭建与回放。
- 构建交互引擎、物料体系、配置协议与数据管线的分层架构，提升系统可扩展性与可维护性。
- 通过状态集中治理与 redux-undo 机制，支撑复杂编辑行为的一致性与可回退能力。

## 九、面试讲解稿（3分钟）
我负责的是一个配置驱动的低代码可视化画布系统。设计重点不是功能堆叠，而是构建稳定的配置协议与可扩展运行时：编辑器产出 configData，服务端持久化，预览与查看再按同一配置回放，保证链路一致。
架构上我把系统拆为四层：交互状态层、物料协议层、配置序列化层、数据请求层。交互层通过 editorSlice 原子 action 收口复杂操作；物料层用类型协议控制扩展边界；数据层用统一参数模型和请求管线处理业务复杂条件。
项目价值在于：短期提升搭建效率，长期形成可治理、可扩展、可演进的低代码平台基础能力。

## 十、高频追问与回答（8组）
1. 为什么是低代码？因为页面由 configData 执行，不依赖手写页面。
2. 如何控制复杂度？通过分层边界+协议约束，而非功能堆叠。
3. 如何处理复杂交互？交互写路径统一收口到 editorSlice。
4. 撤销重做如何实现？基于 redux-undo 管理历史状态。
5. 为什么分离预览态？避免编辑辅助逻辑污染运行态。
6. 新图表如何接入？增加类型协议、渲染映射和配置面板。
7. 如何复用数据逻辑？通过统一参数构建与通用请求 Hook。
8. 平台化下一步？权限、模板、版本治理、多人协作与发布审计。
